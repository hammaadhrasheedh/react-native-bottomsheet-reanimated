{"version":3,"sources":["index.tsx"],"names":["Screen","width","Dimensions","get","height","normalize","elemHeight","parseFloat","PixelRatio","roundToNearestPixel","getOverDragBoundries","snapPoints","top","length","bounce","getNormalizeSnaps","map","snapItem","parentValue","split","getSnapPoints","snapObject","y","getInitialPosition","snapPoint"],"mappings":";;;;;;;AAAA;;AAEA,MAAMA,MAAM,GAAG;AACbC,EAAAA,KAAK,EAAEC,wBAAWC,GAAX,CAAe,QAAf,EAAyBF,KADnB;AAEbG,EAAAA,MAAM,EAAEF,wBAAWC,GAAX,CAAe,QAAf,EAAyBC;AAFpB,CAAf;;AAKO,MAAMC,SAAS,GAAID,MAAD,IAAoB;AAC3C,MAAI,OAAOA,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,WAAOA,MAAP;AACD,GAFD,MAEO;AACL,UAAME,UAAU,GAAGC,UAAU,CAACH,MAAD,CAA7B;AACA,WAAOI,wBAAWC,mBAAX,CAAgCT,MAAM,CAACI,MAAP,GAAgBE,UAAjB,GAA+B,GAA9D,CAAP;AACD;AACF,CAPM;;;;AASA,MAAMI,oBAAoB,GAAIC,UAAD,IAAqB;AACvD,SAAO;AACLC,IAAAA,GAAG,EAAEZ,MAAM,CAACI,MAAP,GAAgBO,UAAU,CAACA,UAAU,CAACE,MAAX,GAAoB,CAArB,CAD1B;AAELC,IAAAA,MAAM,EAAE;AAFH,GAAP;AAID,CALM;;;;AAOA,MAAMC,iBAAiB,GAAIJ,UAAD,IAAqB;AACpD,SAAOA,UAAU,CAACK,GAAX,CAAgBC,QAAD,IAAmB;AACvC,QAAI,OAAOA,QAAP,KAAoB,QAAxB,EAAkC;AAChC,YAAMC,WAAgB,GAAGD,QAAQ,CAACE,KAAT,CAAe,GAAf,EAAoB,CAApB,CAAzB;AACAF,MAAAA,QAAQ,GAAIjB,MAAM,CAACI,MAAP,GAAgB,GAAjB,GAAwBc,WAAnC;AACD;;AACD,WAAOD,QAAP;AACD,GANM,CAAP;AAOD,CARM;;;;AAUA,MAAMG,aAAa,GAAIT,UAAD,IAAqB;AAChD,SAAOA,UAAU,CAACK,GAAX,CAAgBC,QAAD,IAAmB;AACvC,UAAMI,UAAU,GAAG;AAAEC,MAAAA,CAAC,EAAEtB,MAAM,CAACI,MAAP,GAAgBa;AAArB,KAAnB;AACA,WAAOI,UAAP;AACD,GAHM,CAAP;AAID,CALM;;;;AAOA,MAAME,kBAAkB,GAAIC,SAAD,IAAoB;AACpD,MAAI,OAAOA,SAAP,KAAqB,QAAzB,EAAmC;AACjC,UAAMN,WAAgB,GAAGM,SAAS,CAACL,KAAV,CAAgB,GAAhB,EAAqB,CAArB,CAAzB;AACAK,IAAAA,SAAS,GAAIxB,MAAM,CAACI,MAAP,GAAgB,GAAjB,GAAwBc,WAApC;AACD;;AACD,QAAMG,UAAU,GAAG;AAAEC,IAAAA,CAAC,EAAEtB,MAAM,CAACI,MAAP,GAAgBoB;AAArB,GAAnB;AACA,SAAOH,UAAP;AACD,CAPM","sourcesContent":["import { Dimensions, PixelRatio } from 'react-native';\n\nconst Screen = {\n  width: Dimensions.get('window').width,\n  height: Dimensions.get('window').height,\n};\n\nexport const normalize = (height: number) => {\n  if (typeof height === 'number') {\n    return height;\n  } else {\n    const elemHeight = parseFloat(height);\n    return PixelRatio.roundToNearestPixel((Screen.height * elemHeight) / 100);\n  }\n};\n\nexport const getOverDragBoundries = (snapPoints: any) => {\n  return {\n    top: Screen.height - snapPoints[snapPoints.length - 1],\n    bounce: 0,\n  };\n};\n\nexport const getNormalizeSnaps = (snapPoints: any) => {\n  return snapPoints.map((snapItem: any) => {\n    if (typeof snapItem === 'string') {\n      const parentValue: any = snapItem.split('%')[0];\n      snapItem = (Screen.height / 100) * parentValue;\n    }\n    return snapItem;\n  });\n};\n\nexport const getSnapPoints = (snapPoints: any) => {\n  return snapPoints.map((snapItem: any) => {\n    const snapObject = { y: Screen.height - snapItem };\n    return snapObject;\n  });\n};\n\nexport const getInitialPosition = (snapPoint: any) => {\n  if (typeof snapPoint === 'string') {\n    const parentValue: any = snapPoint.split('%')[0];\n    snapPoint = (Screen.height / 100) * parentValue;\n  }\n  const snapObject = { y: Screen.height - snapPoint };\n  return snapObject;\n};\n"]}